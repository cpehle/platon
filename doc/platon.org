* Syntax
** Categories

The syntax of platon is adapted to category theory. While it is not
strictly nescessary to understand category theory for using platon (it
isn't usable anyways), we nevertheless provide a short overview of the
basic definitions in the following.

A category \(C\) is a class of objects \(Ob(C)\) and for every two
objects \(x, y \in Ob(C)\) a set of arrows \(Arr_C(x,y)\).  Arrows can
be composed by a family of maps

$$
∘_{x y z}: Arr_C (x,y) × Arr_C (y,z) → Arr_C (x,z),
$$

which are required to be associative. 

In addition for each object \(x\) in \(C\) the set of arrows
Arr_C(x,x) needs to contain an identity morphism

$$
id_x: Arr_C (x,x),
$$

which is required to be a unit with respect to composition, that is
for all arrows \( f \in Arr(y,x) \):

$$
id_x \circ f = f = f \circ id_y.
$$

In platon given morphisms f ∈ Arr_C(a,b), g ∈ Arr_C(b,c) and h ∈
Arr_C(c,d) their composition is written as

(f g h)

This notation already incorporates the fact that
composition is associative.

** Functors and natural transformations as examples of 2-categories

Given two categories \(C\) und \(D\) a covariant functor \(F : C \to D\)
associates to every object \(x\) in \(C\) an object \(F(x)\) in \(D\)
and to every arrow \(f \in Arr_C(x,y) \) an arrow \(Ff \in Arr_D(Fx,
Fy)\) in such a way that associativity and identity are respected, that is
an arrow

f : x → y

is mapped to an arrow 

Ff : F x → F y

Since functors respect associativity and identity, it makes sense to write

F(f g h) 

to denote the composition of Ff, Fg and Fh in D.

Functors itself can also be composed, that is given functors
F : C → D and G : D → E, their composition will be denoted by

[F G]

The reason for this notation will become clear in a moment, functor composition is also associative, so it is possible to write

[F G H](f g h)

Given two functors F : C → D and G : C → D, a natural transformation

μ : F ⇒ G 

is an arrow \( μ_{x} : F(x) → G(x) \) for every object x ∈ C, such
that for every arrow f : x → y, the following diagram commutes:


F(x) → F(y)
 |      |  
 μ      μ 
 |      |
G(x) → G(y)

Functors and natural transformations form a category of their own,
where functors are the objects and natural transformations are the
arrows. So using the notation introduced above, we can write

(F μ η). 

However as we have seen above, there is anoter way to compose
functors themselves, which we denoted by [F G]. In fact it is also
possible to compose natural transformations in a second way [η μ] and
one has

[(F η) (G μ)] = ([F G] [η μ])

Given functors F : C → D, G : C → D and H : C → D and natural
transformations η : F ⇒ G and μ : G ⇒ H we can compose (η μ), but
given functors F : C → D, G : C → D, H : D → E, I : D → E and natural
transformations η : F ⇒ H and μ : G ⇒ I, we can also compose them in a
second way [η μ], then

Graphically the two forms of composition can be written as follows

|      
|       
η
|
|
μ
|
| 
            

|     |
|     |
η     μ
|     |
|     |


inv: C → C 
Δ: C → C ⊗ C
m: C ⊗ C → C
ρ: A ⊗ C → C

** Examples
*** k-Algebras

[A · + k]

[A + k] is a k vector space

*** Hopf Algebra

{[H + · η Δ ε k] [_ ([H H] H) ([H H] H) (k H) (H [H H])]} 





** Monads


-- Monad is an endo functor
T: C → C
-- together with two natural transformation

pure: I → T 
join: T² → T

         |      |
         |      | 
          \    /
           join
            | 
            | 

([T T] join)

([T T T] [join id] join) == ([T T T] [id join] join)


            
           pure  
            |
            |


So lets assume for a moment, that we have values

readInt :: IO Int
writeInt :: Int → IO Int

(readInt IO(square writeInt) join(_))









fmap : Functor f => (a -> b) -> f a -> f b


If f : T a -> b
then fmap f : T (T a) -> T b







(T(f) join)


(>>=): T a → (T a → b) → T b
a >>= f = join (fmap f a)

T a ⊗ (a, T b ) → T b


fmap: (a,b) → (T a, T b)

h : a → T b 

(T(f g) h T())



-- Input is a T a, where a is an object in C



([T μ] μ)
([μ T] μ)

(
[a₀ a₁] -- T t₀ ⊗ T t₁



T(g f) -- g: A → B, f: B → C, T(g f): T A → T C


)


([μ T] μ)
([T μ] μ)

([η T] μ) 

id

([T η] μ)

– Trace operator

! : C → I 


-- One way data flow
(
 init 
 Δ
 [f g]
 scatter
 [h₀ h₁ h₂]
 gather
 c
)



-- Hom(X ⊗ A, X ⊗ B) → Hom(A,B)

[trace (i) (f Δ [ ] +)]

μ θ γ


g = (Δ                ) (    )


3 4 ρ v – Reshape a vector v of dimension 12 to 3 4
σ – Split the tensor into different domains, should allow for some overlap

init 
∘ dup 
∘ a b 
∘ scatter
∘ f g h 
∘ gather 
∘ c 
∘ mail name 

N σ v

N – Is a potentially nested tensor.






τ [
1 2 3 3 4 5 : vec _ int
Δ   Δ  Δ


σ 2 3 [



] 



σ 2 3 [



]

]


inv inv inv id inv id
m m m 

(f ⊗ g ⊗ h)
⟨x,y⟩

let x = y in z

– This is a another comment


f x → 1 2 3 4
f y z ⇒
f ⊦ s d


↑ ↓ ⟨ ⟩ ∈ ∩ ∪ ∨ ∧ ←


* Reducers / State

A simple way to represent state changes is by reducers, that is pure functions

f : (state, action) -> state

state  action 
\     . 
 \   . 
  \ .
   |
   | 
   |
  state


Now lets suppose that the set of actions satisfies some additional
laws, for example that one can compose to actions to get a new action

action × action → action

```
 .        .  
  .     .  
   .  . 
    .
    .
    .
```


Simplest example would be a non-commutative monoid with identity.


Identity: No action

  id 
  .
  .
  .


Emitter:

   state
    |
    |
    |
   / .
  /   .
 /     .
state signal 






\     . 
 \   . 
  \ .
   |
   | 
   |
   |
   |
   |
  / .    
 /   .   
/     .  



Now suppose we wanted to explicitely keep track of time, for the
moment we will think of time as being given by the integers
\(time = \mathbf{Z}\). All possible states of the system are then given by the product

state × time

there are canonical projections p and q

p : state × time → state

and

q : state × time → time

given a function f : state × action → state and a map s0 : {0} → state, the "initial state" and a function

a : time → action

We can produce a section s : time → state as follows

s(i) = f(s(i-1),a(i))



Now suppose we are several reducers

f_{k} : state_k × action_{k} → state_{k}







Arbiter


arbiter : state × request × enable → state × select × grant × valid

arb_{2} : state_{2} × request_{2} × enable → state × select × grant_{2} × valid

state = { last : Bit(1) }

arb_{2} state req en = ~en ? (state × state.last × 0) : ()




