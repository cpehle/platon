* Reducers / State

A simple way to represent state changes is by reducers, that is pure functions

f : (state, action) -> state

state  action 
\     . 
 \   . 
  \ .
   |
   | 
   |
  state


Now lets suppose that the set of actions satisfies some additional
laws, for example that one can compose to actions to get a new action

action    action
 .        .  
  .     .  
   .  . 
    .
    .
    .
 action

Simplest example would be a non-commutative monoid with identity.


Identity: No action

  id 
  .
  .
  .


Emitter:

   state
    |
    |
    |
   / .
  /   .
 /     .
state signal 






\     . 
 \   . 
  \ .
   |
   | 
   |
   |
   |
   |
  / .    
 /   .   
/     .  



Now suppose we wanted to explicitely keep track of time, for the
moment we will think of time as being given by the integers
\(time = \mathbf{Z}\). All possible states of the system are then given by the product

state × time

there are canonical projections p and q

p : state × time → state

and

q : state × time → time

given a function f : state × action → state and a map s0 : {0} → state, the "initial state" and a function

a : time → action

We can produce a section s : time → state as follows

s(i) = f(s(i-1),a(i))



Now suppose we are several reducers

f_{k} : state_k × action_{k} → state_{k}







Arbiter


arbiter : state × request × enable → state × select × grant × valid

arb_{2} : state_{2} × request_{2} × enable → state × select × grant_{2} × valid

state = { last : Bit(1) }

arb_{2} state req en = ~en ? (state × state.last × 0) : ()





* Syntax


∘: Hom_C (x,y) × Hom_C (y,z) → Hom_C (x,z)
id_x: Hom_C (x,x)



inv: C → C 
Δ: C → C ⊗ C
m: C ⊗ C → C
ρ: A ⊗ C → C



-- Monad is an endo functor
T: C → C
-- together with two natural transformation
pure: I → T 
join: T² → T

         |      |
         |      | 
          \    /
           join
            | 
            | 

            
           pure  
            |
            |












fmap : Functor f => (a -> b) -> f a -> f b


If f : T a -> b
then fmap f : T (T a) -> T b







(T(f) join)


(>>=): T a → (T a → b) → T b
a >>= f = join (fmap f a)

T a ⊗ (a, T b ) → T b


fmap: (a,b) → (T a, T b)

h : a → T b 

(T(f g) h T())



-- Input is a T a, where a is an object in C



([T μ] μ)
([μ T] μ)

(
[a₀ a₁] -- T t₀ ⊗ T t₁



T(g f) -- g: A → B, f: B → C, T(g f): T A → T C


)


([μ T] μ)
([T μ] μ)

([η T] μ) 

id

([T η] μ)

– Trace operator

! : C → I 


-- One way data flow
(
 init 
 Δ
 [f g]
 scatter
 [h₀ h₁ h₂]
 gather
 c
)



-- Hom(X ⊗ A, X ⊗ B) → Hom(A,B)

[trace (i) (f Δ [ ] +)]

μ θ γ


g = (Δ                ) (    )


3 4 ρ v – Reshape a vector v of dimension 12 to 3 4
σ – Split the tensor into different domains, should allow for some overlap

init 
∘ dup 
∘ a b 
∘ scatter
∘ f g h 
∘ gather 
∘ c 
∘ mail name 

N σ v

N – Is a potentially nested tensor.






τ [
1 2 3 3 4 5 : vec _ int
Δ   Δ  Δ


σ 2 3 [



] 



σ 2 3 [



]

]


inv inv inv id inv id
m m m 

(f ⊗ g ⊗ h)
⟨x,y⟩

let x = y in z

– This is a another comment


f x → 1 2 3 4
f y z ⇒
f ⊦ s d


↑ ↓ ⟨ ⟩ ∈ ∩ ∪ ∨ ∧ ←




      ⎧ 
f x = ⎨ 
      ⎩ 


x = fn
  | square x →
  | test y →
  | record z →
  | var y →

